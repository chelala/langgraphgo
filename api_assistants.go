/*
LangGraph Platform

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package langgraphgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AssistantsAPIService AssistantsAPI service
type AssistantsAPIService service

type ApiCreateAssistantAssistantsPostRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantCreate *AssistantCreate
}

func (r ApiCreateAssistantAssistantsPostRequest) AssistantCreate(assistantCreate AssistantCreate) ApiCreateAssistantAssistantsPostRequest {
	r.assistantCreate = &assistantCreate
	return r
}

func (r ApiCreateAssistantAssistantsPostRequest) Execute() (*Assistant, *http.Response, error) {
	return r.ApiService.CreateAssistantAssistantsPostExecute(r)
}

/*
CreateAssistantAssistantsPost Create Assistant

Create an assistant.

An initial version of the assistant will be created and the assistant is set to that version. To change versions, use the `POST /assistants/{assistant_id}/latest` endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssistantAssistantsPostRequest
*/
func (a *AssistantsAPIService) CreateAssistantAssistantsPost(ctx context.Context) ApiCreateAssistantAssistantsPostRequest {
	return ApiCreateAssistantAssistantsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Assistant
func (a *AssistantsAPIService) CreateAssistantAssistantsPostExecute(r ApiCreateAssistantAssistantsPostRequest) (*Assistant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Assistant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.CreateAssistantAssistantsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assistants"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assistantCreate == nil {
		return localVarReturnValue, nil, reportError("assistantCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assistantCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAssistantAssistantsAssistantIdDeleteRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
}

func (r ApiDeleteAssistantAssistantsAssistantIdDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteAssistantAssistantsAssistantIdDeleteExecute(r)
}

/*
DeleteAssistantAssistantsAssistantIdDelete Delete Assistant

Delete an assistant by ID.

All versions of the assistant will be deleted as well.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId The ID of the assistant.
 @return ApiDeleteAssistantAssistantsAssistantIdDeleteRequest
*/
func (a *AssistantsAPIService) DeleteAssistantAssistantsAssistantIdDelete(ctx context.Context, assistantId string) ApiDeleteAssistantAssistantsAssistantIdDeleteRequest {
	return ApiDeleteAssistantAssistantsAssistantIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *AssistantsAPIService) DeleteAssistantAssistantsAssistantIdDeleteExecute(r ApiDeleteAssistantAssistantsAssistantIdDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.DeleteAssistantAssistantsAssistantIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assistants/{assistant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssistantAssistantsAssistantIdGetRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
}

func (r ApiGetAssistantAssistantsAssistantIdGetRequest) Execute() (*Assistant, *http.Response, error) {
	return r.ApiService.GetAssistantAssistantsAssistantIdGetExecute(r)
}

/*
GetAssistantAssistantsAssistantIdGet Get Assistant

Get an assistant by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId The ID of the assistant.
 @return ApiGetAssistantAssistantsAssistantIdGetRequest
*/
func (a *AssistantsAPIService) GetAssistantAssistantsAssistantIdGet(ctx context.Context, assistantId string) ApiGetAssistantAssistantsAssistantIdGetRequest {
	return ApiGetAssistantAssistantsAssistantIdGetRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return Assistant
func (a *AssistantsAPIService) GetAssistantAssistantsAssistantIdGetExecute(r ApiGetAssistantAssistantsAssistantIdGetRequest) (*Assistant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Assistant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.GetAssistantAssistantsAssistantIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assistants/{assistant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssistantGraphAssistantsAssistantIdGraphGetRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId GetAssistantGraphAssistantsAssistantIdGraphGetAssistantIdParameter
	xray *Xray
}

// Include graph representation of subgraphs. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.
func (r ApiGetAssistantGraphAssistantsAssistantIdGraphGetRequest) Xray(xray Xray) ApiGetAssistantGraphAssistantsAssistantIdGraphGetRequest {
	r.xray = &xray
	return r
}

func (r ApiGetAssistantGraphAssistantsAssistantIdGraphGetRequest) Execute() (*map[string][]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAssistantGraphAssistantsAssistantIdGraphGetExecute(r)
}

/*
GetAssistantGraphAssistantsAssistantIdGraphGet Get Assistant Graph

Get an assistant by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId The ID of the assistant.
 @return ApiGetAssistantGraphAssistantsAssistantIdGraphGetRequest
*/
func (a *AssistantsAPIService) GetAssistantGraphAssistantsAssistantIdGraphGet(ctx context.Context, assistantId GetAssistantGraphAssistantsAssistantIdGraphGetAssistantIdParameter) ApiGetAssistantGraphAssistantsAssistantIdGraphGetRequest {
	return ApiGetAssistantGraphAssistantsAssistantIdGraphGetRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return map[string][]map[string]interface{}
func (a *AssistantsAPIService) GetAssistantGraphAssistantsAssistantIdGraphGetExecute(r ApiGetAssistantGraphAssistantsAssistantIdGraphGetRequest) (*map[string][]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string][]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.GetAssistantGraphAssistantsAssistantIdGraphGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assistants/{assistant_id}/graph"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.xray != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "xray", r.xray, "form", "")
	} else {
		falseBool := false
		var defaultValue Xray = Xray{
			Bool: &falseBool,
		}
		r.xray = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssistantSchemasAssistantsAssistantIdSchemasGetRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
}

func (r ApiGetAssistantSchemasAssistantsAssistantIdSchemasGetRequest) Execute() (*GraphSchema, *http.Response, error) {
	return r.ApiService.GetAssistantSchemasAssistantsAssistantIdSchemasGetExecute(r)
}

/*
GetAssistantSchemasAssistantsAssistantIdSchemasGet Get Assistant Schemas

Get an assistant by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId The ID of the assistant.
 @return ApiGetAssistantSchemasAssistantsAssistantIdSchemasGetRequest
*/
func (a *AssistantsAPIService) GetAssistantSchemasAssistantsAssistantIdSchemasGet(ctx context.Context, assistantId string) ApiGetAssistantSchemasAssistantsAssistantIdSchemasGetRequest {
	return ApiGetAssistantSchemasAssistantsAssistantIdSchemasGetRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return GraphSchema
func (a *AssistantsAPIService) GetAssistantSchemasAssistantsAssistantIdSchemasGetExecute(r ApiGetAssistantSchemasAssistantsAssistantIdSchemasGetRequest) (*GraphSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GraphSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.GetAssistantSchemasAssistantsAssistantIdSchemasGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assistants/{assistant_id}/schemas"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsGetRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
	recurse *bool
}

// Recursively retrieve subgraphs of subgraphs.
func (r ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsGetRequest) Recurse(recurse bool) ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsGetRequest {
	r.recurse = &recurse
	return r
}

func (r ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsGetRequest) Execute() (*map[string]GraphSchemaNoId, *http.Response, error) {
	return r.ApiService.GetAssistantSubgraphsAssistantsAssistantIdSubgraphsGetExecute(r)
}

/*
GetAssistantSubgraphsAssistantsAssistantIdSubgraphsGet Get Assistant Subgraphs

Get an assistant's subgraphs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId The ID of the assistant.
 @return ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsGetRequest
*/
func (a *AssistantsAPIService) GetAssistantSubgraphsAssistantsAssistantIdSubgraphsGet(ctx context.Context, assistantId string) ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsGetRequest {
	return ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsGetRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return map[string]GraphSchemaNoId
func (a *AssistantsAPIService) GetAssistantSubgraphsAssistantsAssistantIdSubgraphsGetExecute(r ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsGetRequest) (*map[string]GraphSchemaNoId, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]GraphSchemaNoId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.GetAssistantSubgraphsAssistantsAssistantIdSubgraphsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assistants/{assistant_id}/subgraphs"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "form", "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGetRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
	namespace string
	recurse *bool
}

// Recursively retrieve subgraphs of subgraphs.
func (r ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGetRequest) Recurse(recurse bool) ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGetRequest {
	r.recurse = &recurse
	return r
}

func (r ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGetRequest) Execute() (*map[string]GraphSchemaNoId, *http.Response, error) {
	return r.ApiService.GetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGetExecute(r)
}

/*
GetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGet Get Assistant Subgraphs by Namespace

Get an assistant's subgraphs filtered by namespace.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId The ID of the assistant.
 @param namespace Namespace of the subgraph to filter by.
 @return ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGetRequest
*/
func (a *AssistantsAPIService) GetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGet(ctx context.Context, assistantId string, namespace string) ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGetRequest {
	return ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGetRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return map[string]GraphSchemaNoId
func (a *AssistantsAPIService) GetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGetExecute(r ApiGetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGetRequest) (*map[string]GraphSchemaNoId, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]GraphSchemaNoId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.GetAssistantSubgraphsAssistantsAssistantIdSubgraphsNamespaceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assistants/{assistant_id}/subgraphs/{namespace}"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "form", "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssistantVersionsAssistantsAssistantIdVersionsGetRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
}

func (r ApiGetAssistantVersionsAssistantsAssistantIdVersionsGetRequest) Execute() ([]Assistant, *http.Response, error) {
	return r.ApiService.GetAssistantVersionsAssistantsAssistantIdVersionsGetExecute(r)
}

/*
GetAssistantVersionsAssistantsAssistantIdVersionsGet Get Assistant Versions

Get all versions of an assistant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId The ID of the assistant.
 @return ApiGetAssistantVersionsAssistantsAssistantIdVersionsGetRequest
*/
func (a *AssistantsAPIService) GetAssistantVersionsAssistantsAssistantIdVersionsGet(ctx context.Context, assistantId string) ApiGetAssistantVersionsAssistantsAssistantIdVersionsGetRequest {
	return ApiGetAssistantVersionsAssistantsAssistantIdVersionsGetRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return []Assistant
func (a *AssistantsAPIService) GetAssistantVersionsAssistantsAssistantIdVersionsGetExecute(r ApiGetAssistantVersionsAssistantsAssistantIdVersionsGetRequest) ([]Assistant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Assistant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.GetAssistantVersionsAssistantsAssistantIdVersionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assistants/{assistant_id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchAssistantAssistantsAssistantIdPatchRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantPatch *AssistantPatch
	assistantId string
}

func (r ApiPatchAssistantAssistantsAssistantIdPatchRequest) AssistantPatch(assistantPatch AssistantPatch) ApiPatchAssistantAssistantsAssistantIdPatchRequest {
	r.assistantPatch = &assistantPatch
	return r
}

func (r ApiPatchAssistantAssistantsAssistantIdPatchRequest) Execute() (*Assistant, *http.Response, error) {
	return r.ApiService.PatchAssistantAssistantsAssistantIdPatchExecute(r)
}

/*
PatchAssistantAssistantsAssistantIdPatch Patch Assistant

Update an assistant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId The ID of the assistant.
 @return ApiPatchAssistantAssistantsAssistantIdPatchRequest
*/
func (a *AssistantsAPIService) PatchAssistantAssistantsAssistantIdPatch(ctx context.Context, assistantId string) ApiPatchAssistantAssistantsAssistantIdPatchRequest {
	return ApiPatchAssistantAssistantsAssistantIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return Assistant
func (a *AssistantsAPIService) PatchAssistantAssistantsAssistantIdPatchExecute(r ApiPatchAssistantAssistantsAssistantIdPatchRequest) (*Assistant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Assistant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.PatchAssistantAssistantsAssistantIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assistants/{assistant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assistantPatch == nil {
		return localVarReturnValue, nil, reportError("assistantPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assistantPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchAssistantsAssistantsSearchPostRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantSearchRequest *AssistantSearchRequest
}

func (r ApiSearchAssistantsAssistantsSearchPostRequest) AssistantSearchRequest(assistantSearchRequest AssistantSearchRequest) ApiSearchAssistantsAssistantsSearchPostRequest {
	r.assistantSearchRequest = &assistantSearchRequest
	return r
}

func (r ApiSearchAssistantsAssistantsSearchPostRequest) Execute() ([]Assistant, *http.Response, error) {
	return r.ApiService.SearchAssistantsAssistantsSearchPostExecute(r)
}

/*
SearchAssistantsAssistantsSearchPost Search Assistants

Search for assistants.

This endpoint also functions as the endpoint to list all assistants.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchAssistantsAssistantsSearchPostRequest
*/
func (a *AssistantsAPIService) SearchAssistantsAssistantsSearchPost(ctx context.Context) ApiSearchAssistantsAssistantsSearchPostRequest {
	return ApiSearchAssistantsAssistantsSearchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Assistant
func (a *AssistantsAPIService) SearchAssistantsAssistantsSearchPostExecute(r ApiSearchAssistantsAssistantsSearchPostRequest) ([]Assistant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Assistant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.SearchAssistantsAssistantsSearchPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assistants/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assistantSearchRequest == nil {
		return localVarReturnValue, nil, reportError("assistantSearchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assistantSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetLatestAssistantVersionAssistantsAssistantIdVersionsPostRequest struct {
	ctx context.Context
	ApiService *AssistantsAPIService
	assistantId string
	version *int32
}

// The version to change to.
func (r ApiSetLatestAssistantVersionAssistantsAssistantIdVersionsPostRequest) Version(version int32) ApiSetLatestAssistantVersionAssistantsAssistantIdVersionsPostRequest {
	r.version = &version
	return r
}

func (r ApiSetLatestAssistantVersionAssistantsAssistantIdVersionsPostRequest) Execute() (*Assistant, *http.Response, error) {
	return r.ApiService.SetLatestAssistantVersionAssistantsAssistantIdVersionsPostExecute(r)
}

/*
SetLatestAssistantVersionAssistantsAssistantIdVersionsPost Set Latest Assistant Version

Set the latest version for an assistant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param assistantId The ID of the assistant.
 @return ApiSetLatestAssistantVersionAssistantsAssistantIdVersionsPostRequest
*/
func (a *AssistantsAPIService) SetLatestAssistantVersionAssistantsAssistantIdVersionsPost(ctx context.Context, assistantId string) ApiSetLatestAssistantVersionAssistantsAssistantIdVersionsPostRequest {
	return ApiSetLatestAssistantVersionAssistantsAssistantIdVersionsPostRequest{
		ApiService: a,
		ctx: ctx,
		assistantId: assistantId,
	}
}

// Execute executes the request
//  @return Assistant
func (a *AssistantsAPIService) SetLatestAssistantVersionAssistantsAssistantIdVersionsPostExecute(r ApiSetLatestAssistantVersionAssistantsAssistantIdVersionsPostRequest) (*Assistant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Assistant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssistantsAPIService.SetLatestAssistantVersionAssistantsAssistantIdVersionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assistants/{assistant_id}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"assistant_id"+"}", url.PathEscape(parameterValueToString(r.assistantId, "assistantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.version == nil {
		return localVarReturnValue, nil, reportError("version is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
