/*
LangGraph Platform

Testing ThreadRunsAPIService

*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech);

package langgraphgo_test

import (
	"context"
	"testing"

	"github.com/chelala/langgraphgo"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func Test_langgraphgo_ThreadRunsAPIService(t *testing.T) {

	configuration := langgraphgo.NewConfiguration()
	configuration.Servers = langgraphgo.ServerConfigurations{
		{
			URL:         "http://127.0.0.1:2024",
			Description: "local running server",
		},
	}
	apiClient := langgraphgo.NewAPIClient(configuration)

	t.Run("Test ThreadRunsAPIService CancelRunHttpThreadsThreadIdRunsRunIdCancelPost", func(t *testing.T) {

		t.Skip("skip test") // remove to run test

		var threadId string
		var runId string

		resp, httpRes, err := apiClient.ThreadRunsAPI.CancelRunHttpThreadsThreadIdRunsRunIdCancelPost(context.Background(), threadId, runId).Execute()

		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

	})

	t.Run("Test ThreadRunsAPIService CreateRunThreadsThreadIdRunsPost", func(t *testing.T) {

		t.Skip("skip test") // remove to run test

		var threadId string

		threadRunRequest := apiClient.ThreadRunsAPI.CreateRunThreadsThreadIdRunsPost(context.Background(), threadId)
		threadRunReq := threadRunRequest.RunCreateStateful(langgraphgo.RunCreateStateful{})
		resp, httpRes, err := threadRunReq.Execute()

		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

	})

	t.Run("Test ThreadRunsAPIService DeleteRunThreadsThreadIdRunsRunIdDelete", func(t *testing.T) {

		t.Skip("skip test") // remove to run test

		var threadId string
		var runId string

		resp, httpRes, err := apiClient.ThreadRunsAPI.DeleteRunThreadsThreadIdRunsRunIdDelete(context.Background(), threadId, runId).Execute()

		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

	})

	t.Run("Test ThreadRunsAPIService GetRunHttpThreadsThreadIdRunsRunIdGet", func(t *testing.T) {

		t.Skip("skip test") // remove to run test

		var threadId string
		var runId string

		resp, httpRes, err := apiClient.ThreadRunsAPI.GetRunHttpThreadsThreadIdRunsRunIdGet(context.Background(), threadId, runId).Execute()

		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

	})

	t.Run("Test ThreadRunsAPIService JoinRunHttpThreadsThreadIdRunsRunIdJoinGet", func(t *testing.T) {

		t.Skip("skip test") // remove to run test

		var threadId string
		var runId string

		resp, httpRes, err := apiClient.ThreadRunsAPI.JoinRunHttpThreadsThreadIdRunsRunIdJoinGet(context.Background(), threadId, runId).Execute()

		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

	})

	t.Run("Test ThreadRunsAPIService ListRunsHttpThreadsThreadIdRunsGet", func(t *testing.T) {

		t.Skip("skip test") // remove to run test

		var threadId string

		resp, httpRes, err := apiClient.ThreadRunsAPI.ListRunsHttpThreadsThreadIdRunsGet(context.Background(), threadId).Execute()

		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

	})

	t.Run("Test ThreadRunsAPIService StreamRunHttpThreadsThreadIdRunsRunIdJoinGet", func(t *testing.T) {

		t.Skip("skip test") // remove to run test

		var threadId string
		var runId string

		resp, httpRes, err := apiClient.ThreadRunsAPI.StreamRunHttpThreadsThreadIdRunsRunIdJoinGet(context.Background(), threadId, runId).Execute()

		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

	})

	t.Run("Test ThreadRunsAPIService StreamRunThreadsThreadIdRunsStreamPost", func(t *testing.T) {

		t.Skip("skip test") // remove to run test

		var threadId string

		resp, httpRes, err := apiClient.ThreadRunsAPI.StreamRunThreadsThreadIdRunsStreamPost(context.Background(), threadId).Execute()

		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

	})

	t.Run("Test ThreadRunsAPIService WaitRunThreadsThreadIdRunsWaitPost", func(t *testing.T) {

		// t.Skip("skip test") // remove to run test

		threadId := "86de033f-49a6-44ce-97fc-4d3cca3865c4"
		graphName := "agent"
		inputId := uuid.New()
		// inputtext := "Que hora es?"
		// inputtext := "Cuál es la temperatura en  NYC?"
		// inputtext := "Cuál es la temperatura en  San Francisco?"
		inputtext := "Requisitos para un prestamo Micro?"

		threadRunsWaitAPI := apiClient.ThreadRunsAPI.WaitRunThreadsThreadIdRunsWaitPost(context.Background(), threadId)

		input := map[string]interface{}{
			"messages": []interface{}{
				map[string]interface{}{
					"id":      inputId.String(),
					"content": inputtext,
					"type":    "human",
				},
			},
		}
		threadRunsWaitAPIReq := threadRunsWaitAPI.RunCreateStateful(langgraphgo.RunCreateStateful{
			AssistantId: langgraphgo.RunCreateStatefulAssistantId{
				String: &graphName,
			},
			Input: *langgraphgo.NewNullableInput1(&langgraphgo.Input1{
				MapmapOfStringAny: &input,
			}),
		})

		resp, httpRes, err := threadRunsWaitAPIReq.Execute()

		require.Nil(t, err)
		require.NotNil(t, resp)
		assert.Equal(t, 200, httpRes.StatusCode)

		responseMap, ok := resp.(map[string]interface{})
		require.True(t, ok, "response is not a map[string]interface{}")
		messages, ok := responseMap["messages"].([]interface{})
		require.True(t, ok, "messages is not a []interface{}")
		inputIdFound := false

		var messageRagContexts map[string]interface{} = nil
		if ragContextsItem, exists := responseMap["rag_contexts"]; exists {
			_messageRagContexts, ok := ragContextsItem.(map[string]interface{})
			require.True(t, ok, "rag_contexts is not a map[string]interface{}")
			messageRagContexts = _messageRagContexts

		}

		for _, messageItem := range messages {
			message, ok := messageItem.(map[string]interface{})
			require.True(t, ok, "message is not a map[string]interface{}")

			messageId, ok := message["id"].(string)
			require.True(t, ok, "messageId is not a string")
			messageType, ok := message["type"].(string)
			require.True(t, ok, "messageType is not a string")
			messageContent, ok := message["content"].(string)
			require.True(t, ok, "messageContent is not a string")

			// if the key "name" does not exist or the value under "name" is not a string, the type assertion will return
			// the zero value of the target type (an empty string in this case) without triggering a runtime error.
			// The error (the boolean value) is ignored because it’s assigned to the blank identifier (_).
			messageName, _ := message["name"].(string)

			inputIdFound = inputIdFound || messageId == inputId.String()
			if inputIdFound && messageId != inputId.String() {
				t.Logf("Message ID: %v\n", messageId)
				t.Logf("Message Type: %v\n", messageType)
				t.Logf("Message Name: %v\n", messageName)
				t.Logf("Message Content: %v\n", messageContent)

				// if the message is a rag message and there are rag contexts, print them
				if messageName == "rag" && messageRagContexts != nil {
					if _messageRagContext, exists := messageRagContexts[inputId.String()]; exists {
						t.Logf("Found inputId %s has rag contexts\n", inputId)
						messageRagContext, ok := _messageRagContext.([]interface{})
						require.True(t, ok, "messageRagContext is not a []interface{}")
						for _, documentItem := range messageRagContext {
							document := documentItem.(map[string]interface{})
							metadata, ok := document["metadata"].(map[string]interface{})
							require.True(t, ok, "metadata is not a map[string]interface{}")
							documentId, ok := metadata["id"].(string)
							require.True(t, ok, "documentId is not a string")
							documentContainer, ok := metadata["container"].(string)
							require.True(t, ok, "documentContainer is not a string")
							documentFilename, ok := metadata["filename"].(string)
							require.True(t, ok, "documentFilename is not a string")
							documentPageNumber, ok := metadata["page_number"].(float64)
							require.True(t, ok, "documentPageNumber is not a float64")
							documentContentType, ok := metadata["content_type"].(string)
							require.True(t, ok, "documentContentType is not a string")
							documentPageContent, ok := document["page_content"].(string)
							require.True(t, ok, "documentPageContent is not a string")

							t.Logf("Document ID: %v\n", documentId)
							t.Logf("Document Container: %v\n", documentContainer)
							t.Logf("Document Filename: %v\n", documentFilename)
							t.Logf("Document Page Number: %v\n", documentPageNumber)
							t.Logf("Document Content Type: %v\n", documentContentType)
							if len(documentPageContent) > 20 {
								t.Logf("Document Page Content: %v\n", documentPageContent[:20])
							} else {
								t.Logf("Document Page Content: %v\n", documentPageContent)
							}
						}
					} else {
						t.Logf("inputId %s not found in Rag contexts", inputId)
					}
				}

			}

		}

		t.Logf("Input ID: %v\n", inputId)
		// fmt.Printf("Response: %v", resp)

	})

}
